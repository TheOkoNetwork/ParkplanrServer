{"version":3,"sources":["../lib/cache.js"],"names":["Settings","require","s_prefix","Symbol","Cache","options","prefix","key","GetGlobal","Prefix","Promise","resolve","reject","get","err","result","undefined","data","SetGlobal","set","setFunction","ttl","_Wrap","bind","Get","Set","_cacheGetter","_cacheSetter","then","dataToCache","module","exports"],"mappings":"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","file":"cache.js","sourcesContent":["/**\r\n * Very simple wrapper around node-cache-manager\r\n */\r\n\r\nconst Settings = require(\"./settings\");\r\n\r\nconst s_prefix = Symbol();\r\n\r\nclass Cache {\r\n    /**\r\n     * Create Cache object\r\n     * This object will handle caching data for later use\r\n     * @param {Object} [options]\r\n     * @param {String} [options.prefix] Preface to prepend to all cache keys for this instance\r\n     */\r\n    constructor(options = {}) {\r\n        // setup cache configuration\r\n        this[s_prefix] = options.prefix || \"\";\r\n    }\r\n\r\n    /**\r\n     * Get the prefix used for this caching instance\r\n     * @returns {String} Cache key prefix\r\n     */\r\n    get Prefix() {\r\n        return this[s_prefix] + \"_\";\r\n    }\r\n\r\n    /** \r\n     * Get a cached value\r\n     * @param {String} key Key to request associated data for \r\n     * @returns {Promise<Object>} Returns Promise resolved if data found, rejects if data is not in cache\r\n     */\r\n    Get(key) {\r\n        // prepend our key to restrict our request to our park's cache (avoid conflicts with other APIs)\r\n        return this.GetGlobal(this.Prefix + key);\r\n    }\r\n\r\n    /**\r\n     * Get a globally cached value\r\n     * This is identical to Get, but the requested key will be in scope of the entire library, not just the park that requests the data\r\n     * @param {String} key Key to request associated data for \r\n     * @returns {Promise<Object>} Returns Promise resolved if data found, rejects if data is not in cache\r\n     */\r\n    GetGlobal(key) {\r\n        return new Promise((resolve, reject) => {\r\n            // prepend the prefix to the requested key\r\n            Settings.Cache.get(\"themeparks_\" + key, (err, result) => {\r\n                // reject promise on failure\r\n                if (err) return reject(err);\r\n                // reject on no data returned\r\n                if (result === undefined || result === null) return reject();\r\n\r\n                // resolve promise on successful data\r\n                return resolve(result);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set a cached value\r\n     * @param {String} key Key to set data for\r\n     * @param {Object} data Data to store in cache\r\n     * @param {Object} [options] Additional options for caching (see node-cache-manager)\r\n     * @returns {Promise} Returns Promise resolving if cached data was successfully set\r\n     */\r\n    Set(key, data, options = {}) {\r\n        // add our prefix and pass onto the SetGlobal function\r\n        return this.SetGlobal(this.Prefix + key, data, options);\r\n    }\r\n\r\n    /**\r\n     * Set a cached value library-wide\r\n     * Idential to Set, but cached at a library level instead of for the owning park\r\n     * @param {String} key Key to set data for\r\n     * @param {Object} data Data to store in cache\r\n     * @param {Object} [options] Additional options for caching (see node-cache-manager)\r\n     * @returns {Promise} Returns Promise resolving if cached data was successfully set\r\n     */\r\n    SetGlobal(key, data, options = {}) {\r\n        return new Promise((resolve, reject) => {\r\n            // prepend prefix to key setting\r\n            Settings.Cache.set(\"themeparks_\" + key, data, options, (err) => {\r\n                // if failure, reject Promise\r\n                if (err) return reject(err);\r\n\r\n                // other, resolve\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Wrap a get request and pass a setter to tidy up the usual get/set boilerplate\r\n     * @param {String} key Key to get/set\r\n     * @param {Function} setFunction Function to set data if it is missing from the cache. setFunction should return a Promise\r\n     * @param {Number|Function} [ttl] How long cached result should last. Can be a number (seconds) or a function that will return a value\r\n     */\r\n    Wrap(key, setFunction, ttl) {\r\n        return _Wrap.bind(this)(key, setFunction, this.Get, this.Set, ttl);\r\n    }\r\n\r\n    /**\r\n     * Wrap a get request and pass a setter to tidy up the usual get/set boilerplate. This version sits in the global scope, rather than per-park.\r\n     * @param {String} key Key to get/set\r\n     * @param {Function} setFunction Function to set data if it is missing from the cache. setFunction should return a Promise\r\n     * @param {Number|Function} [ttl] How long cached result should last. Can be a number (seconds) or a function that will return a value\r\n     */\r\n    WrapGlobal(key, setFunction, ttl) {\r\n        return _Wrap.bind(this)(key, setFunction, this.GetGlobal, this.SetGlobal, ttl);\r\n    }\r\n}\r\n\r\n// Internal wrap helper to not copy/paste logic for global and local-scope wraps\r\nfunction _Wrap(key, setFunction, _cacheGetter, _cacheSetter, ttl) {\r\n    return new Promise((resolve, reject) => {\r\n        // attempt to get the requested key (note, no prefix here, it's attached in the Get function)\r\n        //  pass success directly through to resolve\r\n        _cacheGetter.bind(this)(key).then(resolve, () => {\r\n            // if cache miss, call the setFunction to get the new value we want\r\n            setFunction().then((dataToCache) => {\r\n                // work out ttl\r\n                var options = {};\r\n                if (ttl) {\r\n                    //  if it's a function, call the function to get the required ttl\r\n                    if (typeof ttl == \"function\") {\r\n                        ttl = ttl();\r\n                    }\r\n                    options.ttl = ttl;\r\n                }\r\n\r\n                // store in cache\r\n                _cacheSetter.bind(this)(key, dataToCache, options).then(() => {\r\n                    // resolve with newly cached data\r\n                    resolve(dataToCache);\r\n                }, reject);\r\n            }, reject);\r\n        });\r\n    });\r\n}\r\n\r\n// create new cache object and export it\r\nmodule.exports = Cache;"]}